//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.11.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from CommonRegex.g4 by ANTLR 4.11.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419


#pragma warning disable 3021 // Disable StyleCop warning CS3021 re CLSCompliant attribute in generated files.
#pragma warning disable 0108 // Disable StyleCop warning CS0108, hides inherited member in generated files.

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.11.1")]
[System.CLSCompliant(false)]
public partial class CommonRegexParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Quoted=1, BlockQuoted=2, BellChar=3, ControlChar=4, EscapeChar=5, FormFeed=6, 
		NewLine=7, CarriageReturn=8, Tab=9, Backslash=10, HexChar=11, Dot=12, 
		DecimalDigit=13, NotDecimalDigit=14, CharWithProperty=15, CharWithoutProperty=16, 
		WhiteSpace=17, NotWhiteSpace=18, WordChar=19, NotWordChar=20, CharacterClassStart=21, 
		CharacterClassEnd=22, Caret=23, Hyphen=24, QuestionMark=25, Plus=26, Star=27, 
		OpenBrace=28, CloseBrace=29, Comma=30, EndOfSubject=31, Pipe=32, OpenParen=33, 
		CloseParen=34, LessThan=35, GreaterThan=36, SingleQuote=37, Underscore=38, 
		Colon=39, Hash=40, Equals=41, Exclamation=42, Ampersand=43, ALC=44, BLC=45, 
		CLC=46, DLC=47, ELC=48, FLC=49, GLC=50, HLC=51, ILC=52, JLC=53, KLC=54, 
		LLC=55, MLC=56, NLC=57, OLC=58, PLC=59, QLC=60, RLC=61, SLC=62, TLC=63, 
		ULC=64, VLC=65, WLC=66, XLC=67, YLC=68, ZLC=69, AUC=70, BUC=71, CUC=72, 
		DUC=73, EUC=74, FUC=75, GUC=76, HUC=77, IUC=78, JUC=79, KUC=80, LUC=81, 
		MUC=82, NUC=83, OUC=84, PUC=85, QUC=86, RUC=87, SUC=88, TUC=89, UUC=90, 
		VUC=91, WUC=92, XUC=93, YUC=94, ZUC=95, D1=96, D2=97, D3=98, D4=99, D5=100, 
		D6=101, D7=102, D8=103, D9=104, D0=105, OtherChar=106;
	public const int
		RULE_parse = 0, RULE_alternation = 1, RULE_expr = 2, RULE_element = 3, 
		RULE_quantifier = 4, RULE_quantifier_type = 5, RULE_character_class = 6, 
		RULE_capture = 7, RULE_non_capture = 8, RULE_option = 9, RULE_option_flag = 10, 
		RULE_atom = 11, RULE_cc_atom = 12, RULE_shared_atom = 13, RULE_literal = 14, 
		RULE_cc_literal = 15, RULE_shared_literal = 16, RULE_number = 17, RULE_octal_char = 18, 
		RULE_octal_digit = 19, RULE_digits = 20, RULE_digit = 21, RULE_name = 22, 
		RULE_alpha_nums = 23, RULE_non_close_parens = 24, RULE_non_close_paren = 25, 
		RULE_letter = 26;
	public static readonly string[] ruleNames = {
		"parse", "alternation", "expr", "element", "quantifier", "quantifier_type", 
		"character_class", "capture", "non_capture", "option", "option_flag", 
		"atom", "cc_atom", "shared_atom", "literal", "cc_literal", "shared_literal", 
		"number", "octal_char", "octal_digit", "digits", "digit", "name", "alpha_nums", 
		"non_close_parens", "non_close_paren", "letter"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'\\a'", "'\\c'", "'\\e'", "'\\f'", "'\\n'", "'\\r'", 
		"'\\t'", "'\\'", null, "'.'", "'\\d'", "'\\D'", null, null, "'\\s'", "'\\S'", 
		"'\\w'", "'\\W'", "'['", "']'", "'^'", "'-'", "'?'", "'+'", "'*'", "'{'", 
		"'}'", "','", "'$'", "'|'", "'('", "')'", "'<'", "'>'", "'''", "'_'", 
		"':'", "'#'", "'='", "'!'", "'&'", "'a'", "'b'", "'c'", "'d'", "'e'", 
		"'f'", "'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", 
		"'p'", "'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", 
		"'z'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'G'", "'H'", "'I'", 
		"'J'", "'K'", "'L'", "'M'", "'N'", "'O'", "'P'", "'Q'", "'R'", "'S'", 
		"'T'", "'U'", "'V'", "'W'", "'X'", "'Y'", "'Z'", "'1'", "'2'", "'3'", 
		"'4'", "'5'", "'6'", "'7'", "'8'", "'9'", "'0'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Quoted", "BlockQuoted", "BellChar", "ControlChar", "EscapeChar", 
		"FormFeed", "NewLine", "CarriageReturn", "Tab", "Backslash", "HexChar", 
		"Dot", "DecimalDigit", "NotDecimalDigit", "CharWithProperty", "CharWithoutProperty", 
		"WhiteSpace", "NotWhiteSpace", "WordChar", "NotWordChar", "CharacterClassStart", 
		"CharacterClassEnd", "Caret", "Hyphen", "QuestionMark", "Plus", "Star", 
		"OpenBrace", "CloseBrace", "Comma", "EndOfSubject", "Pipe", "OpenParen", 
		"CloseParen", "LessThan", "GreaterThan", "SingleQuote", "Underscore", 
		"Colon", "Hash", "Equals", "Exclamation", "Ampersand", "ALC", "BLC", "CLC", 
		"DLC", "ELC", "FLC", "GLC", "HLC", "ILC", "JLC", "KLC", "LLC", "MLC", 
		"NLC", "OLC", "PLC", "QLC", "RLC", "SLC", "TLC", "ULC", "VLC", "WLC", 
		"XLC", "YLC", "ZLC", "AUC", "BUC", "CUC", "DUC", "EUC", "FUC", "GUC", 
		"HUC", "IUC", "JUC", "KUC", "LUC", "MUC", "NUC", "OUC", "PUC", "QUC", 
		"RUC", "SUC", "TUC", "UUC", "VUC", "WUC", "XUC", "YUC", "ZUC", "D1", "D2", 
		"D3", "D4", "D5", "D6", "D7", "D8", "D9", "D0", "OtherChar"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "CommonRegex.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static CommonRegexParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public CommonRegexParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public CommonRegexParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ParseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AlternationContext alternation() {
			return GetRuleContext<AlternationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(CommonRegexParser.Eof, 0); }
		public ParseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parse; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterParse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitParse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParseContext parse() {
		ParseContext _localctx = new ParseContext(Context, State);
		EnterRule(_localctx, 0, RULE_parse);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 54;
			alternation();
			State = 55;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlternationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Pipe() { return GetTokens(CommonRegexParser.Pipe); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Pipe(int i) {
			return GetToken(CommonRegexParser.Pipe, i);
		}
		public AlternationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alternation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterAlternation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitAlternation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlternation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlternationContext alternation() {
		AlternationContext _localctx = new AlternationContext(Context, State);
		EnterRule(_localctx, 2, RULE_alternation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 57;
			expr();
			State = 62;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Pipe) {
				{
				{
				State = 58;
				Match(Pipe);
				State = 59;
				expr();
				}
				}
				State = 64;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ElementContext[] element() {
			return GetRuleContexts<ElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElementContext element(int i) {
			return GetRuleContext<ElementContext>(i);
		}
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		ExprContext _localctx = new ExprContext(Context, State);
		EnterRule(_localctx, 4, RULE_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 68;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((_la) & ~0x3f) == 0 && ((1L << _la) & -21709717506L) != 0 || (((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 8796093022207L) != 0) {
				{
				{
				State = 65;
				element();
				}
				}
				State = 70;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public ElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementContext element() {
		ElementContext _localctx = new ElementContext(Context, State);
		EnterRule(_localctx, 6, RULE_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 71;
			atom();
			State = 73;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				{
				State = 72;
				quantifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuantifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Quantifier_typeContext quantifier_type() {
			return GetRuleContext<Quantifier_typeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(CommonRegexParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Star() { return GetToken(CommonRegexParser.Star, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(CommonRegexParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumberContext[] number() {
			return GetRuleContexts<NumberContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NumberContext number(int i) {
			return GetRuleContext<NumberContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(CommonRegexParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(CommonRegexParser.Comma, 0); }
		public QuantifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterQuantifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitQuantifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QuantifierContext quantifier() {
		QuantifierContext _localctx = new QuantifierContext(Context, State);
		EnterRule(_localctx, 8, RULE_quantifier);
		try {
			State = 99;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 75;
				Match(QuestionMark);
				State = 76;
				quantifier_type();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 77;
				Match(Plus);
				State = 78;
				quantifier_type();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 79;
				Match(Star);
				State = 80;
				quantifier_type();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 81;
				Match(OpenBrace);
				State = 82;
				number();
				State = 83;
				Match(CloseBrace);
				State = 84;
				quantifier_type();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 86;
				Match(OpenBrace);
				State = 87;
				number();
				State = 88;
				Match(Comma);
				State = 89;
				Match(CloseBrace);
				State = 90;
				quantifier_type();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 92;
				Match(OpenBrace);
				State = 93;
				number();
				State = 94;
				Match(Comma);
				State = 95;
				number();
				State = 96;
				Match(CloseBrace);
				State = 97;
				quantifier_type();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quantifier_typeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(CommonRegexParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		public Quantifier_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantifier_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterQuantifier_type(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitQuantifier_type(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantifier_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Quantifier_typeContext quantifier_type() {
		Quantifier_typeContext _localctx = new Quantifier_typeContext(Context, State);
		EnterRule(_localctx, 10, RULE_quantifier_type);
		try {
			State = 104;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Plus:
				EnterOuterAlt(_localctx, 1);
				{
				State = 101;
				Match(Plus);
				}
				break;
			case QuestionMark:
				EnterOuterAlt(_localctx, 2);
				{
				State = 102;
				Match(QuestionMark);
				}
				break;
			case Eof:
			case Quoted:
			case BlockQuoted:
			case BellChar:
			case ControlChar:
			case EscapeChar:
			case FormFeed:
			case NewLine:
			case CarriageReturn:
			case Tab:
			case Backslash:
			case HexChar:
			case Dot:
			case DecimalDigit:
			case NotDecimalDigit:
			case CharWithProperty:
			case CharWithoutProperty:
			case WhiteSpace:
			case NotWhiteSpace:
			case WordChar:
			case NotWordChar:
			case CharacterClassStart:
			case CharacterClassEnd:
			case Caret:
			case Hyphen:
			case OpenBrace:
			case CloseBrace:
			case Comma:
			case EndOfSubject:
			case Pipe:
			case OpenParen:
			case CloseParen:
			case LessThan:
			case GreaterThan:
			case SingleQuote:
			case Underscore:
			case Colon:
			case Hash:
			case Equals:
			case Exclamation:
			case Ampersand:
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
			case D1:
			case D2:
			case D3:
			case D4:
			case D5:
			case D6:
			case D7:
			case D8:
			case D9:
			case D0:
			case OtherChar:
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Character_classContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CharacterClassStart() { return GetToken(CommonRegexParser.CharacterClassStart, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Caret() { return GetToken(CommonRegexParser.Caret, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CharacterClassEnd() { return GetToken(CommonRegexParser.CharacterClassEnd, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Cc_atomContext[] cc_atom() {
			return GetRuleContexts<Cc_atomContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Cc_atomContext cc_atom(int i) {
			return GetRuleContext<Cc_atomContext>(i);
		}
		public Character_classContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_character_class; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterCharacter_class(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitCharacter_class(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharacter_class(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Character_classContext character_class() {
		Character_classContext _localctx = new Character_classContext(Context, State);
		EnterRule(_localctx, 12, RULE_character_class);
		int _la;
		try {
			State = 123;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 106;
				Match(CharacterClassStart);
				State = 107;
				Match(Caret);
				State = 109;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 108;
					cc_atom();
					}
					}
					State = 111;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( ((_la) & ~0x3f) == 0 && ((1L << _la) & -4194306L) != 0 || (((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 8796093022207L) != 0 );
				State = 113;
				Match(CharacterClassEnd);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 115;
				Match(CharacterClassStart);
				State = 117;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 116;
					cc_atom();
					}
					}
					State = 119;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( ((_la) & ~0x3f) == 0 && ((1L << _la) & -4194306L) != 0 || (((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 8796093022207L) != 0 );
				State = 121;
				Match(CharacterClassEnd);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaptureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(CommonRegexParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LessThan() { return GetToken(CommonRegexParser.LessThan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GreaterThan() { return GetToken(CommonRegexParser.GreaterThan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlternationContext alternation() {
			return GetRuleContext<AlternationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public CaptureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_capture; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterCapture(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitCapture(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCapture(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaptureContext capture() {
		CaptureContext _localctx = new CaptureContext(Context, State);
		EnterRule(_localctx, 14, RULE_capture);
		try {
			State = 137;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 125;
				Match(OpenParen);
				State = 126;
				Match(QuestionMark);
				State = 127;
				Match(LessThan);
				State = 128;
				name();
				State = 129;
				Match(GreaterThan);
				State = 130;
				alternation();
				State = 131;
				Match(CloseParen);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 133;
				Match(OpenParen);
				State = 134;
				alternation();
				State = 135;
				Match(CloseParen);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_captureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(CommonRegexParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(CommonRegexParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlternationContext alternation() {
			return GetRuleContext<AlternationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public Non_captureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_capture; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterNon_capture(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitNon_capture(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_capture(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_captureContext non_capture() {
		Non_captureContext _localctx = new Non_captureContext(Context, State);
		EnterRule(_localctx, 16, RULE_non_capture);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 139;
			Match(OpenParen);
			State = 140;
			Match(QuestionMark);
			State = 141;
			Match(Colon);
			State = 142;
			alternation();
			State = 143;
			Match(CloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(CommonRegexParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Option_flagContext[] option_flag() {
			return GetRuleContexts<Option_flagContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Option_flagContext option_flag(int i) {
			return GetRuleContext<Option_flagContext>(i);
		}
		public OptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_option; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionContext option() {
		OptionContext _localctx = new OptionContext(Context, State);
		EnterRule(_localctx, 18, RULE_option);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 145;
			Match(OpenParen);
			State = 146;
			Match(QuestionMark);
			State = 148;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 147;
				option_flag();
				}
				}
				State = 150;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( ((_la) & ~0x3f) == 0 && ((1L << _la) & 4688247212092686336L) != 0 );
			State = 152;
			Match(CloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Option_flagContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ILC() { return GetToken(CommonRegexParser.ILC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MLC() { return GetToken(CommonRegexParser.MLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLC() { return GetToken(CommonRegexParser.SLC, 0); }
		public Option_flagContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_option_flag; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterOption_flag(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitOption_flag(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOption_flag(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Option_flagContext option_flag() {
		Option_flagContext _localctx = new Option_flagContext(Context, State);
		EnterRule(_localctx, 20, RULE_option_flag);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 154;
			_la = TokenStream.LA(1);
			if ( !(((_la) & ~0x3f) == 0 && ((1L << _la) & 4688247212092686336L) != 0) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Shared_atomContext shared_atom() {
			return GetRuleContext<Shared_atomContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Character_classContext character_class() {
			return GetRuleContext<Character_classContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaptureContext capture() {
			return GetRuleContext<CaptureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Non_captureContext non_capture() {
			return GetRuleContext<Non_captureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OptionContext option() {
			return GetRuleContext<OptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(CommonRegexParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Caret() { return GetToken(CommonRegexParser.Caret, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EndOfSubject() { return GetToken(CommonRegexParser.EndOfSubject, 0); }
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 22, RULE_atom);
		try {
			State = 165;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 156;
				shared_atom();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 157;
				literal();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 158;
				character_class();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 159;
				capture();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 160;
				non_capture();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 161;
				option();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 162;
				Match(Dot);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 163;
				Match(Caret);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 164;
				Match(EndOfSubject);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cc_atomContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Cc_literalContext[] cc_literal() {
			return GetRuleContexts<Cc_literalContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Cc_literalContext cc_literal(int i) {
			return GetRuleContext<Cc_literalContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hyphen() { return GetToken(CommonRegexParser.Hyphen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Shared_atomContext shared_atom() {
			return GetRuleContext<Shared_atomContext>(0);
		}
		public Cc_atomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cc_atom; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterCc_atom(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitCc_atom(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCc_atom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cc_atomContext cc_atom() {
		Cc_atomContext _localctx = new Cc_atomContext(Context, State);
		EnterRule(_localctx, 24, RULE_cc_atom);
		try {
			State = 173;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 167;
				cc_literal();
				State = 168;
				Match(Hyphen);
				State = 169;
				cc_literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 171;
				shared_atom();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 172;
				cc_literal();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Shared_atomContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ControlChar() { return GetToken(CommonRegexParser.ControlChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecimalDigit() { return GetToken(CommonRegexParser.DecimalDigit, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NotDecimalDigit() { return GetToken(CommonRegexParser.NotDecimalDigit, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CharWithProperty() { return GetToken(CommonRegexParser.CharWithProperty, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CharWithoutProperty() { return GetToken(CommonRegexParser.CharWithoutProperty, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WhiteSpace() { return GetToken(CommonRegexParser.WhiteSpace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NotWhiteSpace() { return GetToken(CommonRegexParser.NotWhiteSpace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WordChar() { return GetToken(CommonRegexParser.WordChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NotWordChar() { return GetToken(CommonRegexParser.NotWordChar, 0); }
		public Shared_atomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shared_atom; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterShared_atom(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitShared_atom(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShared_atom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Shared_atomContext shared_atom() {
		Shared_atomContext _localctx = new Shared_atomContext(Context, State);
		EnterRule(_localctx, 26, RULE_shared_atom);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 175;
			_la = TokenStream.LA(1);
			if ( !(((_la) & ~0x3f) == 0 && ((1L << _la) & 2088976L) != 0) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Shared_literalContext shared_literal() {
			return GetRuleContext<Shared_literalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CharacterClassEnd() { return GetToken(CommonRegexParser.CharacterClassEnd, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 28, RULE_literal);
		try {
			State = 179;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Quoted:
			case BlockQuoted:
			case BellChar:
			case EscapeChar:
			case FormFeed:
			case NewLine:
			case CarriageReturn:
			case Tab:
			case Backslash:
			case HexChar:
			case Hyphen:
			case OpenBrace:
			case CloseBrace:
			case Comma:
			case LessThan:
			case GreaterThan:
			case SingleQuote:
			case Underscore:
			case Colon:
			case Hash:
			case Equals:
			case Exclamation:
			case Ampersand:
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
			case D1:
			case D2:
			case D3:
			case D4:
			case D5:
			case D6:
			case D7:
			case D8:
			case D9:
			case D0:
			case OtherChar:
				EnterOuterAlt(_localctx, 1);
				{
				State = 177;
				shared_literal();
				}
				break;
			case CharacterClassEnd:
				EnterOuterAlt(_localctx, 2);
				{
				State = 178;
				Match(CharacterClassEnd);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cc_literalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Shared_literalContext shared_literal() {
			return GetRuleContext<Shared_literalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(CommonRegexParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CharacterClassStart() { return GetToken(CommonRegexParser.CharacterClassStart, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Caret() { return GetToken(CommonRegexParser.Caret, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(CommonRegexParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(CommonRegexParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Star() { return GetToken(CommonRegexParser.Star, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EndOfSubject() { return GetToken(CommonRegexParser.EndOfSubject, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Pipe() { return GetToken(CommonRegexParser.Pipe, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(CommonRegexParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public Cc_literalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cc_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterCc_literal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitCc_literal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCc_literal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cc_literalContext cc_literal() {
		Cc_literalContext _localctx = new Cc_literalContext(Context, State);
		EnterRule(_localctx, 30, RULE_cc_literal);
		try {
			State = 192;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Quoted:
			case BlockQuoted:
			case BellChar:
			case EscapeChar:
			case FormFeed:
			case NewLine:
			case CarriageReturn:
			case Tab:
			case Backslash:
			case HexChar:
			case Hyphen:
			case OpenBrace:
			case CloseBrace:
			case Comma:
			case LessThan:
			case GreaterThan:
			case SingleQuote:
			case Underscore:
			case Colon:
			case Hash:
			case Equals:
			case Exclamation:
			case Ampersand:
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
			case D1:
			case D2:
			case D3:
			case D4:
			case D5:
			case D6:
			case D7:
			case D8:
			case D9:
			case D0:
			case OtherChar:
				EnterOuterAlt(_localctx, 1);
				{
				State = 181;
				shared_literal();
				}
				break;
			case Dot:
				EnterOuterAlt(_localctx, 2);
				{
				State = 182;
				Match(Dot);
				}
				break;
			case CharacterClassStart:
				EnterOuterAlt(_localctx, 3);
				{
				State = 183;
				Match(CharacterClassStart);
				}
				break;
			case Caret:
				EnterOuterAlt(_localctx, 4);
				{
				State = 184;
				Match(Caret);
				}
				break;
			case QuestionMark:
				EnterOuterAlt(_localctx, 5);
				{
				State = 185;
				Match(QuestionMark);
				}
				break;
			case Plus:
				EnterOuterAlt(_localctx, 6);
				{
				State = 186;
				Match(Plus);
				}
				break;
			case Star:
				EnterOuterAlt(_localctx, 7);
				{
				State = 187;
				Match(Star);
				}
				break;
			case EndOfSubject:
				EnterOuterAlt(_localctx, 8);
				{
				State = 188;
				Match(EndOfSubject);
				}
				break;
			case Pipe:
				EnterOuterAlt(_localctx, 9);
				{
				State = 189;
				Match(Pipe);
				}
				break;
			case OpenParen:
				EnterOuterAlt(_localctx, 10);
				{
				State = 190;
				Match(OpenParen);
				}
				break;
			case CloseParen:
				EnterOuterAlt(_localctx, 11);
				{
				State = 191;
				Match(CloseParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Shared_literalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Octal_charContext octal_char() {
			return GetRuleContext<Octal_charContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LetterContext letter() {
			return GetRuleContext<LetterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DigitContext digit() {
			return GetRuleContext<DigitContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BellChar() { return GetToken(CommonRegexParser.BellChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EscapeChar() { return GetToken(CommonRegexParser.EscapeChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FormFeed() { return GetToken(CommonRegexParser.FormFeed, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NewLine() { return GetToken(CommonRegexParser.NewLine, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CarriageReturn() { return GetToken(CommonRegexParser.CarriageReturn, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Tab() { return GetToken(CommonRegexParser.Tab, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HexChar() { return GetToken(CommonRegexParser.HexChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Quoted() { return GetToken(CommonRegexParser.Quoted, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BlockQuoted() { return GetToken(CommonRegexParser.BlockQuoted, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(CommonRegexParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(CommonRegexParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(CommonRegexParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hyphen() { return GetToken(CommonRegexParser.Hyphen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LessThan() { return GetToken(CommonRegexParser.LessThan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GreaterThan() { return GetToken(CommonRegexParser.GreaterThan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SingleQuote() { return GetToken(CommonRegexParser.SingleQuote, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Underscore() { return GetToken(CommonRegexParser.Underscore, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(CommonRegexParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Hash() { return GetToken(CommonRegexParser.Hash, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equals() { return GetToken(CommonRegexParser.Equals, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Exclamation() { return GetToken(CommonRegexParser.Exclamation, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand() { return GetToken(CommonRegexParser.Ampersand, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OtherChar() { return GetToken(CommonRegexParser.OtherChar, 0); }
		public Shared_literalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shared_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterShared_literal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitShared_literal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShared_literal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Shared_literalContext shared_literal() {
		Shared_literalContext _localctx = new Shared_literalContext(Context, State);
		EnterRule(_localctx, 32, RULE_shared_literal);
		try {
			State = 220;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Backslash:
				EnterOuterAlt(_localctx, 1);
				{
				State = 194;
				octal_char();
				}
				break;
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 195;
				letter();
				}
				break;
			case D1:
			case D2:
			case D3:
			case D4:
			case D5:
			case D6:
			case D7:
			case D8:
			case D9:
			case D0:
				EnterOuterAlt(_localctx, 3);
				{
				State = 196;
				digit();
				}
				break;
			case BellChar:
				EnterOuterAlt(_localctx, 4);
				{
				State = 197;
				Match(BellChar);
				}
				break;
			case EscapeChar:
				EnterOuterAlt(_localctx, 5);
				{
				State = 198;
				Match(EscapeChar);
				}
				break;
			case FormFeed:
				EnterOuterAlt(_localctx, 6);
				{
				State = 199;
				Match(FormFeed);
				}
				break;
			case NewLine:
				EnterOuterAlt(_localctx, 7);
				{
				State = 200;
				Match(NewLine);
				}
				break;
			case CarriageReturn:
				EnterOuterAlt(_localctx, 8);
				{
				State = 201;
				Match(CarriageReturn);
				}
				break;
			case Tab:
				EnterOuterAlt(_localctx, 9);
				{
				State = 202;
				Match(Tab);
				}
				break;
			case HexChar:
				EnterOuterAlt(_localctx, 10);
				{
				State = 203;
				Match(HexChar);
				}
				break;
			case Quoted:
				EnterOuterAlt(_localctx, 11);
				{
				State = 204;
				Match(Quoted);
				}
				break;
			case BlockQuoted:
				EnterOuterAlt(_localctx, 12);
				{
				State = 205;
				Match(BlockQuoted);
				}
				break;
			case OpenBrace:
				EnterOuterAlt(_localctx, 13);
				{
				State = 206;
				Match(OpenBrace);
				}
				break;
			case CloseBrace:
				EnterOuterAlt(_localctx, 14);
				{
				State = 207;
				Match(CloseBrace);
				}
				break;
			case Comma:
				EnterOuterAlt(_localctx, 15);
				{
				State = 208;
				Match(Comma);
				}
				break;
			case Hyphen:
				EnterOuterAlt(_localctx, 16);
				{
				State = 209;
				Match(Hyphen);
				}
				break;
			case LessThan:
				EnterOuterAlt(_localctx, 17);
				{
				State = 210;
				Match(LessThan);
				}
				break;
			case GreaterThan:
				EnterOuterAlt(_localctx, 18);
				{
				State = 211;
				Match(GreaterThan);
				}
				break;
			case SingleQuote:
				EnterOuterAlt(_localctx, 19);
				{
				State = 212;
				Match(SingleQuote);
				}
				break;
			case Underscore:
				EnterOuterAlt(_localctx, 20);
				{
				State = 213;
				Match(Underscore);
				}
				break;
			case Colon:
				EnterOuterAlt(_localctx, 21);
				{
				State = 214;
				Match(Colon);
				}
				break;
			case Hash:
				EnterOuterAlt(_localctx, 22);
				{
				State = 215;
				Match(Hash);
				}
				break;
			case Equals:
				EnterOuterAlt(_localctx, 23);
				{
				State = 216;
				Match(Equals);
				}
				break;
			case Exclamation:
				EnterOuterAlt(_localctx, 24);
				{
				State = 217;
				Match(Exclamation);
				}
				break;
			case Ampersand:
				EnterOuterAlt(_localctx, 25);
				{
				State = 218;
				Match(Ampersand);
				}
				break;
			case OtherChar:
				EnterOuterAlt(_localctx, 26);
				{
				State = 219;
				Match(OtherChar);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DigitsContext digits() {
			return GetRuleContext<DigitsContext>(0);
		}
		public NumberContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_number; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberContext number() {
		NumberContext _localctx = new NumberContext(Context, State);
		EnterRule(_localctx, 34, RULE_number);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			digits();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Octal_charContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Backslash() { return GetToken(CommonRegexParser.Backslash, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Octal_digitContext[] octal_digit() {
			return GetRuleContexts<Octal_digitContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Octal_digitContext octal_digit(int i) {
			return GetRuleContext<Octal_digitContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D0() { return GetToken(CommonRegexParser.D0, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D1() { return GetToken(CommonRegexParser.D1, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D2() { return GetToken(CommonRegexParser.D2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D3() { return GetToken(CommonRegexParser.D3, 0); }
		public Octal_charContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_octal_char; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterOctal_char(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitOctal_char(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOctal_char(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Octal_charContext octal_char() {
		Octal_charContext _localctx = new Octal_charContext(Context, State);
		EnterRule(_localctx, 36, RULE_octal_char);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 233;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				{
				State = 224;
				Match(Backslash);
				State = 225;
				_la = TokenStream.LA(1);
				if ( !((((_la - 96)) & ~0x3f) == 0 && ((1L << (_la - 96)) & 519L) != 0) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 226;
				octal_digit();
				State = 227;
				octal_digit();
				}
				break;
			case 2:
				{
				State = 229;
				Match(Backslash);
				State = 230;
				octal_digit();
				State = 231;
				octal_digit();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Octal_digitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D0() { return GetToken(CommonRegexParser.D0, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D1() { return GetToken(CommonRegexParser.D1, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D2() { return GetToken(CommonRegexParser.D2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D3() { return GetToken(CommonRegexParser.D3, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D4() { return GetToken(CommonRegexParser.D4, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D5() { return GetToken(CommonRegexParser.D5, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D6() { return GetToken(CommonRegexParser.D6, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D7() { return GetToken(CommonRegexParser.D7, 0); }
		public Octal_digitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_octal_digit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterOctal_digit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitOctal_digit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOctal_digit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Octal_digitContext octal_digit() {
		Octal_digitContext _localctx = new Octal_digitContext(Context, State);
		EnterRule(_localctx, 38, RULE_octal_digit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 235;
			_la = TokenStream.LA(1);
			if ( !((((_la - 96)) & ~0x3f) == 0 && ((1L << (_la - 96)) & 639L) != 0) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DigitsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DigitContext[] digit() {
			return GetRuleContexts<DigitContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DigitContext digit(int i) {
			return GetRuleContext<DigitContext>(i);
		}
		public DigitsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_digits; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterDigits(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitDigits(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDigits(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DigitsContext digits() {
		DigitsContext _localctx = new DigitsContext(Context, State);
		EnterRule(_localctx, 40, RULE_digits);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 238;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 237;
				digit();
				}
				}
				State = 240;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la - 96)) & ~0x3f) == 0 && ((1L << (_la - 96)) & 1023L) != 0 );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DigitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D0() { return GetToken(CommonRegexParser.D0, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D1() { return GetToken(CommonRegexParser.D1, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D2() { return GetToken(CommonRegexParser.D2, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D3() { return GetToken(CommonRegexParser.D3, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D4() { return GetToken(CommonRegexParser.D4, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D5() { return GetToken(CommonRegexParser.D5, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D6() { return GetToken(CommonRegexParser.D6, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D7() { return GetToken(CommonRegexParser.D7, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D8() { return GetToken(CommonRegexParser.D8, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode D9() { return GetToken(CommonRegexParser.D9, 0); }
		public DigitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_digit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterDigit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitDigit(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDigit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DigitContext digit() {
		DigitContext _localctx = new DigitContext(Context, State);
		EnterRule(_localctx, 42, RULE_digit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 242;
			_la = TokenStream.LA(1);
			if ( !((((_la - 96)) & ~0x3f) == 0 && ((1L << (_la - 96)) & 1023L) != 0) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Alpha_numsContext alpha_nums() {
			return GetRuleContext<Alpha_numsContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(Context, State);
		EnterRule(_localctx, 44, RULE_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 244;
			alpha_nums();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alpha_numsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LetterContext[] letter() {
			return GetRuleContexts<LetterContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LetterContext letter(int i) {
			return GetRuleContext<LetterContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Underscore() { return GetTokens(CommonRegexParser.Underscore); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Underscore(int i) {
			return GetToken(CommonRegexParser.Underscore, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DigitContext[] digit() {
			return GetRuleContexts<DigitContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DigitContext digit(int i) {
			return GetRuleContext<DigitContext>(i);
		}
		public Alpha_numsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alpha_nums; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterAlpha_nums(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitAlpha_nums(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlpha_nums(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alpha_numsContext alpha_nums() {
		Alpha_numsContext _localctx = new Alpha_numsContext(Context, State);
		EnterRule(_localctx, 46, RULE_alpha_nums);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 248;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALC:
			case BLC:
			case CLC:
			case DLC:
			case ELC:
			case FLC:
			case GLC:
			case HLC:
			case ILC:
			case JLC:
			case KLC:
			case LLC:
			case MLC:
			case NLC:
			case OLC:
			case PLC:
			case QLC:
			case RLC:
			case SLC:
			case TLC:
			case ULC:
			case VLC:
			case WLC:
			case XLC:
			case YLC:
			case ZLC:
			case AUC:
			case BUC:
			case CUC:
			case DUC:
			case EUC:
			case FUC:
			case GUC:
			case HUC:
			case IUC:
			case JUC:
			case KUC:
			case LUC:
			case MUC:
			case NUC:
			case OUC:
			case PUC:
			case QUC:
			case RUC:
			case SUC:
			case TUC:
			case UUC:
			case VUC:
			case WUC:
			case XUC:
			case YUC:
			case ZUC:
				{
				State = 246;
				letter();
				}
				break;
			case Underscore:
				{
				State = 247;
				Match(Underscore);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 255;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((_la) & ~0x3f) == 0 && ((1L << _la) & -17317308137472L) != 0 || (((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 4398046511103L) != 0) {
				{
				State = 253;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ALC:
				case BLC:
				case CLC:
				case DLC:
				case ELC:
				case FLC:
				case GLC:
				case HLC:
				case ILC:
				case JLC:
				case KLC:
				case LLC:
				case MLC:
				case NLC:
				case OLC:
				case PLC:
				case QLC:
				case RLC:
				case SLC:
				case TLC:
				case ULC:
				case VLC:
				case WLC:
				case XLC:
				case YLC:
				case ZLC:
				case AUC:
				case BUC:
				case CUC:
				case DUC:
				case EUC:
				case FUC:
				case GUC:
				case HUC:
				case IUC:
				case JUC:
				case KUC:
				case LUC:
				case MUC:
				case NUC:
				case OUC:
				case PUC:
				case QUC:
				case RUC:
				case SUC:
				case TUC:
				case UUC:
				case VUC:
				case WUC:
				case XUC:
				case YUC:
				case ZUC:
					{
					State = 250;
					letter();
					}
					break;
				case Underscore:
					{
					State = 251;
					Match(Underscore);
					}
					break;
				case D1:
				case D2:
				case D3:
				case D4:
				case D5:
				case D6:
				case D7:
				case D8:
				case D9:
				case D0:
					{
					State = 252;
					digit();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 257;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_close_parensContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Non_close_parenContext[] non_close_paren() {
			return GetRuleContexts<Non_close_parenContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Non_close_parenContext non_close_paren(int i) {
			return GetRuleContext<Non_close_parenContext>(i);
		}
		public Non_close_parensContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_close_parens; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterNon_close_parens(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitNon_close_parens(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_close_parens(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_close_parensContext non_close_parens() {
		Non_close_parensContext _localctx = new Non_close_parensContext(Context, State);
		EnterRule(_localctx, 48, RULE_non_close_parens);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 259;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 258;
				non_close_paren();
				}
				}
				State = 261;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( ((_la) & ~0x3f) == 0 && ((1L << _la) & -17179869186L) != 0 || (((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 8796093022207L) != 0 );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_close_parenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(CommonRegexParser.CloseParen, 0); }
		public Non_close_parenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_close_paren; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterNon_close_paren(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitNon_close_paren(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_close_paren(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_close_parenContext non_close_paren() {
		Non_close_parenContext _localctx = new Non_close_parenContext(Context, State);
		EnterRule(_localctx, 50, RULE_non_close_paren);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 263;
			_la = TokenStream.LA(1);
			if ( _la <= 0 || (_la==CloseParen) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALC() { return GetToken(CommonRegexParser.ALC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLC() { return GetToken(CommonRegexParser.BLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLC() { return GetToken(CommonRegexParser.CLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DLC() { return GetToken(CommonRegexParser.DLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELC() { return GetToken(CommonRegexParser.ELC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLC() { return GetToken(CommonRegexParser.FLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GLC() { return GetToken(CommonRegexParser.GLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HLC() { return GetToken(CommonRegexParser.HLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ILC() { return GetToken(CommonRegexParser.ILC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JLC() { return GetToken(CommonRegexParser.JLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KLC() { return GetToken(CommonRegexParser.KLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LLC() { return GetToken(CommonRegexParser.LLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MLC() { return GetToken(CommonRegexParser.MLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NLC() { return GetToken(CommonRegexParser.NLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OLC() { return GetToken(CommonRegexParser.OLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLC() { return GetToken(CommonRegexParser.PLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QLC() { return GetToken(CommonRegexParser.QLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RLC() { return GetToken(CommonRegexParser.RLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLC() { return GetToken(CommonRegexParser.SLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TLC() { return GetToken(CommonRegexParser.TLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ULC() { return GetToken(CommonRegexParser.ULC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VLC() { return GetToken(CommonRegexParser.VLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WLC() { return GetToken(CommonRegexParser.WLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XLC() { return GetToken(CommonRegexParser.XLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YLC() { return GetToken(CommonRegexParser.YLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZLC() { return GetToken(CommonRegexParser.ZLC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUC() { return GetToken(CommonRegexParser.AUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUC() { return GetToken(CommonRegexParser.BUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CUC() { return GetToken(CommonRegexParser.CUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DUC() { return GetToken(CommonRegexParser.DUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EUC() { return GetToken(CommonRegexParser.EUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUC() { return GetToken(CommonRegexParser.FUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GUC() { return GetToken(CommonRegexParser.GUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HUC() { return GetToken(CommonRegexParser.HUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IUC() { return GetToken(CommonRegexParser.IUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JUC() { return GetToken(CommonRegexParser.JUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KUC() { return GetToken(CommonRegexParser.KUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LUC() { return GetToken(CommonRegexParser.LUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MUC() { return GetToken(CommonRegexParser.MUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUC() { return GetToken(CommonRegexParser.NUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OUC() { return GetToken(CommonRegexParser.OUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PUC() { return GetToken(CommonRegexParser.PUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUC() { return GetToken(CommonRegexParser.QUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RUC() { return GetToken(CommonRegexParser.RUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUC() { return GetToken(CommonRegexParser.SUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TUC() { return GetToken(CommonRegexParser.TUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UUC() { return GetToken(CommonRegexParser.UUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VUC() { return GetToken(CommonRegexParser.VUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WUC() { return GetToken(CommonRegexParser.WUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XUC() { return GetToken(CommonRegexParser.XUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YUC() { return GetToken(CommonRegexParser.YUC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZUC() { return GetToken(CommonRegexParser.ZUC, 0); }
		public LetterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.EnterLetter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICommonRegexListener typedListener = listener as ICommonRegexListener;
			if (typedListener != null) typedListener.ExitLetter(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICommonRegexVisitor<TResult> typedVisitor = visitor as ICommonRegexVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetterContext letter() {
		LetterContext _localctx = new LetterContext(Context, State);
		EnterRule(_localctx, 52, RULE_letter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 265;
			_la = TokenStream.LA(1);
			if ( !((((_la - 44)) & ~0x3f) == 0 && ((1L << (_la - 44)) & 4503599627370495L) != 0) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,106,268,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
		7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,1,0,1,0,1,0,1,1,1,1,
		1,1,5,1,61,8,1,10,1,12,1,64,9,1,1,2,5,2,67,8,2,10,2,12,2,70,9,2,1,3,1,
		3,3,3,74,8,3,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,
		4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,3,4,100,8,4,1,5,1,5,1,5,3,5,105,
		8,5,1,6,1,6,1,6,4,6,110,8,6,11,6,12,6,111,1,6,1,6,1,6,1,6,4,6,118,8,6,
		11,6,12,6,119,1,6,1,6,3,6,124,8,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
		1,7,1,7,1,7,3,7,138,8,7,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,4,9,149,8,
		9,11,9,12,9,150,1,9,1,9,1,10,1,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,
		11,1,11,3,11,166,8,11,1,12,1,12,1,12,1,12,1,12,1,12,3,12,174,8,12,1,13,
		1,13,1,14,1,14,3,14,180,8,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,
		15,1,15,1,15,3,15,193,8,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
		1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
		1,16,1,16,1,16,3,16,221,8,16,1,17,1,17,1,18,1,18,1,18,1,18,1,18,1,18,1,
		18,1,18,1,18,3,18,234,8,18,1,19,1,19,1,20,4,20,239,8,20,11,20,12,20,240,
		1,21,1,21,1,22,1,22,1,23,1,23,3,23,249,8,23,1,23,1,23,1,23,5,23,254,8,
		23,10,23,12,23,257,9,23,1,24,4,24,260,8,24,11,24,12,24,261,1,25,1,25,1,
		26,1,26,1,26,0,0,27,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,
		38,40,42,44,46,48,50,52,0,7,3,0,52,52,56,56,62,62,2,0,4,4,13,20,2,0,96,
		98,105,105,2,0,96,102,105,105,1,0,96,105,1,0,34,34,1,0,44,95,308,0,54,
		1,0,0,0,2,57,1,0,0,0,4,68,1,0,0,0,6,71,1,0,0,0,8,99,1,0,0,0,10,104,1,0,
		0,0,12,123,1,0,0,0,14,137,1,0,0,0,16,139,1,0,0,0,18,145,1,0,0,0,20,154,
		1,0,0,0,22,165,1,0,0,0,24,173,1,0,0,0,26,175,1,0,0,0,28,179,1,0,0,0,30,
		192,1,0,0,0,32,220,1,0,0,0,34,222,1,0,0,0,36,233,1,0,0,0,38,235,1,0,0,
		0,40,238,1,0,0,0,42,242,1,0,0,0,44,244,1,0,0,0,46,248,1,0,0,0,48,259,1,
		0,0,0,50,263,1,0,0,0,52,265,1,0,0,0,54,55,3,2,1,0,55,56,5,0,0,1,56,1,1,
		0,0,0,57,62,3,4,2,0,58,59,5,32,0,0,59,61,3,4,2,0,60,58,1,0,0,0,61,64,1,
		0,0,0,62,60,1,0,0,0,62,63,1,0,0,0,63,3,1,0,0,0,64,62,1,0,0,0,65,67,3,6,
		3,0,66,65,1,0,0,0,67,70,1,0,0,0,68,66,1,0,0,0,68,69,1,0,0,0,69,5,1,0,0,
		0,70,68,1,0,0,0,71,73,3,22,11,0,72,74,3,8,4,0,73,72,1,0,0,0,73,74,1,0,
		0,0,74,7,1,0,0,0,75,76,5,25,0,0,76,100,3,10,5,0,77,78,5,26,0,0,78,100,
		3,10,5,0,79,80,5,27,0,0,80,100,3,10,5,0,81,82,5,28,0,0,82,83,3,34,17,0,
		83,84,5,29,0,0,84,85,3,10,5,0,85,100,1,0,0,0,86,87,5,28,0,0,87,88,3,34,
		17,0,88,89,5,30,0,0,89,90,5,29,0,0,90,91,3,10,5,0,91,100,1,0,0,0,92,93,
		5,28,0,0,93,94,3,34,17,0,94,95,5,30,0,0,95,96,3,34,17,0,96,97,5,29,0,0,
		97,98,3,10,5,0,98,100,1,0,0,0,99,75,1,0,0,0,99,77,1,0,0,0,99,79,1,0,0,
		0,99,81,1,0,0,0,99,86,1,0,0,0,99,92,1,0,0,0,100,9,1,0,0,0,101,105,5,26,
		0,0,102,105,5,25,0,0,103,105,1,0,0,0,104,101,1,0,0,0,104,102,1,0,0,0,104,
		103,1,0,0,0,105,11,1,0,0,0,106,107,5,21,0,0,107,109,5,23,0,0,108,110,3,
		24,12,0,109,108,1,0,0,0,110,111,1,0,0,0,111,109,1,0,0,0,111,112,1,0,0,
		0,112,113,1,0,0,0,113,114,5,22,0,0,114,124,1,0,0,0,115,117,5,21,0,0,116,
		118,3,24,12,0,117,116,1,0,0,0,118,119,1,0,0,0,119,117,1,0,0,0,119,120,
		1,0,0,0,120,121,1,0,0,0,121,122,5,22,0,0,122,124,1,0,0,0,123,106,1,0,0,
		0,123,115,1,0,0,0,124,13,1,0,0,0,125,126,5,33,0,0,126,127,5,25,0,0,127,
		128,5,35,0,0,128,129,3,44,22,0,129,130,5,36,0,0,130,131,3,2,1,0,131,132,
		5,34,0,0,132,138,1,0,0,0,133,134,5,33,0,0,134,135,3,2,1,0,135,136,5,34,
		0,0,136,138,1,0,0,0,137,125,1,0,0,0,137,133,1,0,0,0,138,15,1,0,0,0,139,
		140,5,33,0,0,140,141,5,25,0,0,141,142,5,39,0,0,142,143,3,2,1,0,143,144,
		5,34,0,0,144,17,1,0,0,0,145,146,5,33,0,0,146,148,5,25,0,0,147,149,3,20,
		10,0,148,147,1,0,0,0,149,150,1,0,0,0,150,148,1,0,0,0,150,151,1,0,0,0,151,
		152,1,0,0,0,152,153,5,34,0,0,153,19,1,0,0,0,154,155,7,0,0,0,155,21,1,0,
		0,0,156,166,3,26,13,0,157,166,3,28,14,0,158,166,3,12,6,0,159,166,3,14,
		7,0,160,166,3,16,8,0,161,166,3,18,9,0,162,166,5,12,0,0,163,166,5,23,0,
		0,164,166,5,31,0,0,165,156,1,0,0,0,165,157,1,0,0,0,165,158,1,0,0,0,165,
		159,1,0,0,0,165,160,1,0,0,0,165,161,1,0,0,0,165,162,1,0,0,0,165,163,1,
		0,0,0,165,164,1,0,0,0,166,23,1,0,0,0,167,168,3,30,15,0,168,169,5,24,0,
		0,169,170,3,30,15,0,170,174,1,0,0,0,171,174,3,26,13,0,172,174,3,30,15,
		0,173,167,1,0,0,0,173,171,1,0,0,0,173,172,1,0,0,0,174,25,1,0,0,0,175,176,
		7,1,0,0,176,27,1,0,0,0,177,180,3,32,16,0,178,180,5,22,0,0,179,177,1,0,
		0,0,179,178,1,0,0,0,180,29,1,0,0,0,181,193,3,32,16,0,182,193,5,12,0,0,
		183,193,5,21,0,0,184,193,5,23,0,0,185,193,5,25,0,0,186,193,5,26,0,0,187,
		193,5,27,0,0,188,193,5,31,0,0,189,193,5,32,0,0,190,193,5,33,0,0,191,193,
		5,34,0,0,192,181,1,0,0,0,192,182,1,0,0,0,192,183,1,0,0,0,192,184,1,0,0,
		0,192,185,1,0,0,0,192,186,1,0,0,0,192,187,1,0,0,0,192,188,1,0,0,0,192,
		189,1,0,0,0,192,190,1,0,0,0,192,191,1,0,0,0,193,31,1,0,0,0,194,221,3,36,
		18,0,195,221,3,52,26,0,196,221,3,42,21,0,197,221,5,3,0,0,198,221,5,5,0,
		0,199,221,5,6,0,0,200,221,5,7,0,0,201,221,5,8,0,0,202,221,5,9,0,0,203,
		221,5,11,0,0,204,221,5,1,0,0,205,221,5,2,0,0,206,221,5,28,0,0,207,221,
		5,29,0,0,208,221,5,30,0,0,209,221,5,24,0,0,210,221,5,35,0,0,211,221,5,
		36,0,0,212,221,5,37,0,0,213,221,5,38,0,0,214,221,5,39,0,0,215,221,5,40,
		0,0,216,221,5,41,0,0,217,221,5,42,0,0,218,221,5,43,0,0,219,221,5,106,0,
		0,220,194,1,0,0,0,220,195,1,0,0,0,220,196,1,0,0,0,220,197,1,0,0,0,220,
		198,1,0,0,0,220,199,1,0,0,0,220,200,1,0,0,0,220,201,1,0,0,0,220,202,1,
		0,0,0,220,203,1,0,0,0,220,204,1,0,0,0,220,205,1,0,0,0,220,206,1,0,0,0,
		220,207,1,0,0,0,220,208,1,0,0,0,220,209,1,0,0,0,220,210,1,0,0,0,220,211,
		1,0,0,0,220,212,1,0,0,0,220,213,1,0,0,0,220,214,1,0,0,0,220,215,1,0,0,
		0,220,216,1,0,0,0,220,217,1,0,0,0,220,218,1,0,0,0,220,219,1,0,0,0,221,
		33,1,0,0,0,222,223,3,40,20,0,223,35,1,0,0,0,224,225,5,10,0,0,225,226,7,
		2,0,0,226,227,3,38,19,0,227,228,3,38,19,0,228,234,1,0,0,0,229,230,5,10,
		0,0,230,231,3,38,19,0,231,232,3,38,19,0,232,234,1,0,0,0,233,224,1,0,0,
		0,233,229,1,0,0,0,234,37,1,0,0,0,235,236,7,3,0,0,236,39,1,0,0,0,237,239,
		3,42,21,0,238,237,1,0,0,0,239,240,1,0,0,0,240,238,1,0,0,0,240,241,1,0,
		0,0,241,41,1,0,0,0,242,243,7,4,0,0,243,43,1,0,0,0,244,245,3,46,23,0,245,
		45,1,0,0,0,246,249,3,52,26,0,247,249,5,38,0,0,248,246,1,0,0,0,248,247,
		1,0,0,0,249,255,1,0,0,0,250,254,3,52,26,0,251,254,5,38,0,0,252,254,3,42,
		21,0,253,250,1,0,0,0,253,251,1,0,0,0,253,252,1,0,0,0,254,257,1,0,0,0,255,
		253,1,0,0,0,255,256,1,0,0,0,256,47,1,0,0,0,257,255,1,0,0,0,258,260,3,50,
		25,0,259,258,1,0,0,0,260,261,1,0,0,0,261,259,1,0,0,0,261,262,1,0,0,0,262,
		49,1,0,0,0,263,264,8,5,0,0,264,51,1,0,0,0,265,266,7,6,0,0,266,53,1,0,0,
		0,21,62,68,73,99,104,111,119,123,137,150,165,173,179,192,220,233,240,248,
		253,255,261
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
